

********************Lab Task 1 ********************
file=argv.c

#include <stdio.h>
int main(int argc, char *argv[]){
        printf("Total number of arguments: %d\n", argc);

        for(int i = 0; i < argc; i++){
                printf("Argument %d: %s\n", i+1, argv[i]);
        }

        return 0;
}

gcc argv.c -o argv
./argv hello pritesh 123

#include <stdio.h>
#include <unistd.h>
#include <limits.h>

int main(int argc, char *argv[]){
        char cwd[PATH_MAX]; //buffer to store current directory

        if (getcwd(cwd, sizeof(cwd)) != NULL){
                printf("Current Directory: %s\n", cwd);
        }else{
                perror("getcwd() error");
                return 1;
        }

        if(argc == 2){
                if(chdir(argv[1]) == 0){
                        if(getcwd(cwd, sizeof(cwd)) != NULL){
                                printf("Changed to Directory: %s\n", cwd);
                        }else{
                                perror("getcwd() error after chdir");
                                return 1;
                        }
                }else{
                        perror("chdir() error");
                        return 1;
                }
        }
        return 0;
}

gcc getcwd.c -o getcwd
/getcwd
------------------------------------------------------------------------------------------
********************Lab Task 2********************
Write these programs in the lab and show to the lab incharge.  All programs to be written using the syscalls open(), read(), write(), close() and lseek(). 

1)Write a program that opens 3 files, and shows that the FD obtained are 3, 4, 5 respectively.  Use argv. Filename: threefds.c

#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]){
        if(argc != 4){
                const char *msg = "Usage: ./threefds <file1> <file2> <file3\n>";
                write(2, msg, strlen(msg));
                return 1;
        }

        int fd1 = open(argv[1], O_CREAT | O_WRONLY, 0644);
        int fd2 = open(argv[2], O_CREAT | O_WRONLY, 0644);
        int fd3 = open(argv[3], O_CREAT | O_WRONLY, 0644);

        if (fd1 == -1 || fd2 == -1 || fd3 == -1){
                write(2, "Error opening files\n", 20);
                return 1;
        }

        char buffer[100];
        int len = sprintf(buffer, "FDs obtained: %d %d %d\n", fd1, fd2, fd3);
        write(1, buffer, len);

        close(fd1);
        close(fd2);
        close(fd3);

        return 0;
}

gcc threefds.c -o threefds
./threefds a.txt b.txt c.txt

----------------------------------------------------------------------------------------
2)Write a program that shows that open() fails due to three different reasons. For this, use the concept that open() returns -1 on failure, and the global variable errno is set to indicate the reason of failure. Read "man 2 open". Embed the filenames in the code, do not use argv.  Filename: openfails.c

#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>

int main(){
        int fd;
        char buffer[200];
        int len;

        //File doesn't exist (without O_CREAT)
        fd = open("nofile.txt", O_RDONLY);
        len = sprintf(buffer, "Open nofile.txt: %s\n", strerror(errno));
        write(1, buffer, len);

        //Permission Denied
        fd = open("/etc/shadow", O_WRONLY);
        len = sprintf(buffer, "Open /etc/shadow: %s\n", strerror(errno));
        write(1, buffer, len);

        //Invalid Path
        fd = open("/invalid/path/file.txt", O_RDONLY);
        len = sprintf(buffer, "Open /invalid/path/file.txt: %s\n", strerror(errno));
        write(1, buffer, len);

        return 0;
}
gcc openfails.c -o openfails
./openfails
----------------------------------------------------------------------------------------
3)Write a program that demonstrates read(0, ...) and write(1, ...) works.  In this write a function mygetchar() and myputchar() which works like getchar() and putchar() respectively.   Filename: getputchar.c

#include <unistd.h>
int mygetchar(){
	char c;
	if(read(0, &c, 1) == 1){
		return c;
	}
	else{		return -1;
	}
}
void myputchar(char c){
	write(1, &c, 1);
}
int main(){
	char ch;
	write(1, "Enter text (Ctrl+D to stop):\n", 29);
	while((ch = mygetchar()) != -1){
		myputchar(ch); 
	}
	return 0;
}

gcc getputchar.c -o getputchar
./getputchar

------------------------------------------------------------------------------------------
********************Lab Task 3 ********************

1)Show that exec() can fail, for at least 2 different reasons
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main(){
	//Try to run a file that doesn't exist
	if(execl("/bin/nonexistent", "nonexistent", NULL) == -1){
		perror("exec failed: file doesn't exist");
	}

	//Try to run a file without execute permission
	if(execl("./not_executable", "not_executable", NULL) == -1){
		perror("exec failed: no execute permission");
	}
		
	const char *msg = "Hello, after exec failed !!\n";
	write(2, msg, strlen(msg));
	return 0;
}
gcc myexec.c -o myexec
touch not_executable
chmod 644 not_executable
./myexec
------------------------------------------------------------------------------------------
2)Show that you can call execl(), execvp() and execlp() 
#include <stdio.h>
#include <unistd.h>

int main(){
	//since the current process will get replaced only one will execute, to check the output of every exec() syscalls comment out others :)
	
	//execl
	printf("Using execl (full path):\n");
	execl("/bin/ls", "ls", "-l", NULL);

	//if execl() fails, we will reach here
	perror("execl failed !!");
	
	//execlp
	printf("Using execlp (search in PATH): \n");
	execlp("ls", "ls", "-l", NULL);
	perror("execlp failed !!");

	//execvp
	printf("Using execvp (array of arguments): \n");
	char *args[] = {"ls", "-l", NULL};
	execvp("ls", args);
	perror("execvp failed !!");
	
	//if exec works, the current process is replaced
	return 0;
}

gcc otherexec.c -o otherexec
./otherexec 
------------------------------------------------------------------------------------------
3)Write a small C program showing how output redirection can be done by closing (1) and opening a file. 
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main(){
	//fd1 is stdout and closed it so the next open() will reuse fd1
	close(1);

	open("output.txt", O_CREAT | O_WRONLY, 0644);
	
	//Now the output text will redirect to the output.txt file!!
	//printf("This text goes into output.txt, not the terminal!\n");
	write(1, "This text goes into output.txt, not the terminal!\n", 50);

	return 0;

}
gcc redirect.c -o redirect
./redirect
------------------------------------------------------------------------------------------
4)Write a program that calls fork() twice, or thrice, and one/two of them inside some if-else. 
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main(){
	printf("Start: PID=%d\n", getpid());

	//first fork
	if(fork() == 0){
		printf("Child 1: PID = %d, Parent = %d\n", getpid(), getppid());
		if(fork() == 0){
			printf("Child 1.1: PID = %d, Parent = %d\n", getpid(), getppid());
		}
	}else{
		fork();
		printf("Parent/Other: PID = %d, Parent = %d\n", getpid(), getppid());
		while(wait(NULL) > 0); //wait for all children
	}
	return 0;
}
 gcc myfork.c -o myfork
 ./myfork
 ------------------------------------------------------------------------------------------
 ********************Lab Task 4 ********************
 1)Write a program in 3 separate C files. Compile and link them separately and run the program. The program can be a very simple code, emphasis is showing that you can run the commands.   FILES:  main.c  a.c  b.c  
 
 a.c =>
 #include <stdio.h>
void fA(){
	printf("This is function A!\n");
}

b.c=>
#include <stdio.h>
void fB(){
	printf("This is function B!\n");
}

main.c=>
#include <stdio.h>
void fA();
void fB();
int main(){
	printf("This is main!\n");
	fA();
	fB();
	return 0;
}
 gcc main.c a.c b.c -o program
./program
------------------------------------------------------------------------------------------
2)Write a Makefile for the above program. Submit Makefile. 
CC = gcc
CFLAGS = -Wall -g

all: program

program: main.o a.o b.o
	$(CC) $(CFLAGS) -o program main.o a.o b.o

main.o: main.c
	$(CC) $(CFLAGS) -c main.c

a.o: a.c
	$(CC) $(CFLAGS) -c a.c

b.o: b.c
	$(CC) $(CFLAGS) -c b.c

clean:
	rm -f *.o program

make
./program
make clean
------------------------------------------------------------------------------------------
3)Write a C program, with main() and one more function f() that main calls.. Compile it with gcc -S . See the assembly code.
#include <stdio.h>
int f(int x){
    int y = x + 5;
    return y;
}
int main(){
    int a = 10;
    a = f(a);
    return a;
}
gcc -S stackdemo.c -o stackdemo.s
cat stackdemo.s

procshow.c=>
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[], char *envp[]){
    printf("PID = %d\n", getpid());
    printf("Program running... press Ctrl+C to stop.\n");

    while (1) sleep(1);
    return 0;
}

gcc procshow.c -o procshow
./procshow
Now open another terminal to inspect /proc/12345/
cat /proc/12345/cmdline

-NUMBER OF CONTEXT SWITCHES
grep ctxt /proc/12345/status

- OPEN FILES
ls -l /proc/12345/fd

-NUMBER OF BYTES OF I/O DONE
cat /proc/12345/io

- ENVIRONMENT PASSED TO THE PROGRAM
cat /proc/12345/environ | tr '\0' '\n'
------------------------------------------------------------------------------------------
4) Write a C program and demonstrate that it goes through following states using ps and /proc/status :  RUNNING, SLEEPING, RUNNABLE, ZOMBIE

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
int main(){
	pid_t pid = fork();
	if (pid == 0){
		printf("Child PID: %d\n", getpid());

		printf("Child is RUNNING...\n");
		sleep(1);
		printf("Child going to SLEEP for 5 seconds...\n");
		sleep(5);
		printf("Child exiting now (will become ZOMBIE)...\n");
		exit(0);
	} else {
		printf("Parent PID: %d, Child PID: %d\n", getpid(), pid);
		sleep(2);
		printf("Check child status in /proc/%d/status or using ps\n", pid);
		sleep(6); //during this time, child should have exited and is a zombie
		wait(NULL);
		printf("Child reaped. Zombie cleared\n");
	}
	return 0;
}
gcc status-change.c -o status-change
./status-change
 ------------------------------------------------------------------------------------------
 ********************Lab Task 5 ********************
1)Write any 3 commands using  PIPE and ls, cat, grep, echo  which work on Linux but not xv6. 
# 1. List files, search for '.txt', and count lines
ls -l | grep '\.txt$' | wc -l
# 2. Show unique environment variables
echo "$PATH" | tr ':' '\n' | grep 'bin'
# 3. Concatenate all *.log files and find "error"
cat *.log | grep -i "error" | sort | uniq

2)Measure the time it takes to run the usertests and stresssfs  and write it in a file 
real	0m36.445s
user	0m35.910s
sys	0m0.918s

3)Observe the code in usertests.c and mention any three differences in the system calls on Linux and xv6, and write them in a file. 
1. Error Handling
xv6:	int fd = open("file.txt", 0);
	if(fd < 0){printf("open failed\n");}
Linux:	int fd = open("file.txt", O_RDONLY);
	if(fd < 0){perror("open failed"); //errno is set
	}
Difference: xv6 has no errno mechanism, only -1 return values.
2. Process Control
xv6:if(fork() == 0){ exec("echo", argv);
       } else {  wait(0); }
Linux: if(fork() == 0){
         execvp("echo", argv);  // multiple exec variants
       } else { waitpid(-1, &status, 0); }
Difference: xv6 only provides wait() and exec(), Linux has waitpid(), execve(), execvp(), etc.
3. File Operations
xv6:int fd = open("file.txt", O_CREATE | O_WRONLY);
Linux:	int fd = open("file.txt", O_CREAT | O_WRONLY | O_APPEND | O_CLOEXEC, 0644);
Difference: xv6 supports only minimal flags (O_CREATE, O_RDONLY, O_WRONLY, O_RDWR), while Linux supports many more (O_APPEND, O_NONBLOCK, O_SYNC, etc.).

Write in one Line each, description of the Makefile  contents and write it in a file. Following contents from Makefile:  Line 79 CFLAGS =,  line 96 dd if=kernel, line 148 _%: , line 159 mkfs, line 224 qemu 
79 CFLAGS = These are the flags the compiler uses when making the kernel and programs.
96 dd if=kernel = This command puts the kernel into the disk image.
148 _%: = A generic rule in Makefile to help build different targets.
159 mkfs = This makes the filesystem for xv6 to use.
224 qemu = This runs xv6 in the QEMU emulator so we can see it work.

 ------------------------------------------------------------------------------------------
 ********************Lab Task 6a ********************
 Add hello world system call to xv6
 
1️⃣ Add syscall number → syscall.h
#define SYS_hello 22

2️⃣ Add kernel function implementation → sysproc.c
int sys_hello(void)
{
  cprintf("hello world\n");
  return 0;
}

3️⃣ Register syscall with dispatch table → syscall.c
Add in syscalls[] array: [SYS_hello] sys_hello,
Also add declaration: extern int sys_hello(void);

4️⃣ Expose syscall to user programs → user.h
Add: int hello(void);

5️⃣ Add syscall entry stub → usys.S
Add: SYSCALL(hello)

6️⃣ Create user program → hello.c
#include "types.h"
#include "stat.h"
#include "user.h"
int main(void)
{
    hello();   // syscall invoked
    exit();
}

7️⃣ Add program to xv6 Makefile so hello gets built
In Makefile under UPROGS:
_hello\

then make clean
make qemu
$ hello

Patch file=>
git init
git checkout -b pritesh
git reset --hard eeb7b415dbcb12cc362d0783e41c3d1f44066b17
git add .
git commit -m "Added pritesh system call"
git diff eeb7b415dbcb12cc362d0783e41c3d1f44066b17 > pritesh_syscall.patch
cat pritesh_syscall.patch

 ------------------------------------------------------------------------------------------
 ********************Lab Task 8 ********************
 Demonstrate the following using BASH Shell:
1. Show the nth line of a file:
sed -n '5p' viraj.txt
OR
awk 'NR==5' viraj.txt

2. Find MIS IDs present in file1 but not in file2: 
grep -Fxv -f file2 file1

3. Find all HREF links in a HTML file:
grep -oP 'href="\K[^"]+' file.html
 ------------------------------------------------------------------------------------------
 ********************Lab Task 9 ********************
 Write a program to print n'th group descriptor from an ext2 file system.  filename: nthgd.c 
 
 #include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

typedef struct {
    uint32_t block_bitmap;
    uint32_t inode_bitmap;
    uint32_t inode_table;
    uint16_t free_blocks;
    uint16_t free_inodes;
    uint16_t used_dirs;
    uint16_t pad;
    uint32_t reserved[3];
} GD;

int main(int argc, char *argv[]) {
    if(argc != 3){
        printf("Usage: %s <image> <group#>\n", argv[0]);
        return 1;
    }

    FILE *f = fopen(argv[1], "rb");
    if(!f){ perror("open"); return 1; }

    int n = atoi(argv[2]);

    fseek(f, 1024+24, SEEK_SET); // s_log_block_size
    uint32_t log_blk; fread(&log
        _blk,4,1,f);
    uint32_t blk_size = 1024 << log_blk;

    long gd_off = (blk_size==1024 ? 2048 : blk_size) + n*32;
    fseek(f, gd_off, SEEK_SET);

    GD gd;
    fread(&gd,sizeof(GD),1,f);

    printf("Group %d:\nBlock bitmap=%u\nInode bitmap=%u\nInode table=%u\nFree blocks=%u\nFree inodes=%u\nUsed dirs=%u\n",
           n, gd.block_bitmap, gd.inode_bitmap, gd.inode_table, gd.free_blocks, gd.free_inodes, gd.used_dirs);

    fclose(f);
    return 0;
}

gcc nthgd.c -o nthgd
./nthgd <filesystem.img> <group_number>
example ./nthgd ext2.img 0
------------------------------------------------------------------------------------------
2)Write another program to print n'th data block from an ext2 file system.   Filename: nthblock.c

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

int main(int argc,char *argv[]){
    if(argc!=3){ printf("Usage: %s <image> <block#>\n",argv[0]); return 1; }

    FILE *f=fopen(argv[1],"rb");
    if(!f){
        perror("open");
        return 1;
    }

    int blk=atoi(argv[2]);

    fseek(f,1024+24,SEEK_SET);
    uint32_t log_blk; fread(&log_blk,4,1,f);
    uint32_t blk_size=1024<<log_blk;

    fseek(f,blk*blk_size,SEEK_SET);

    unsigned char *b=malloc(blk_size);
    fread(b,1,blk_size,f);

    printf("Block %d (hex):\n",blk);
    for(int i=0;i<blk_size;i++){
        printf("%02x ",b[i]);
        if((i+1)%16==0) printf("\n");
    }

    free(b); fclose(f);
    return 0;
}
gcc -o nthblock nthblock.c
./nthblock <image-file> <block-number>
Example:./nthblock ext2.img 5
 ------------------------------------------------------------------------------------------
 ************************** Assignment no 2  **************************
 Q.This program is a simple version of the "grep" command.

Write a program without using printf, scanf, getchar, putchar (and related standard I/O functions) , without using FILE, fopen, etc; and only using open(), read(), write(), close(), lseek(): 
which reads a text file, specified as command line argument (argv[1]) and reads a word from standard input and
prints all lines from the text file containing given word (here word is a character sequence, it need not be separated with space)

#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){
	if(argc != 2){
		write(2, "Usage: ./mygrep <file>\n", 22);
		return 1;
	}

	char word[100];
	write(1, "Enter Word: ", 12);
	int wlen = read(0, word, sizeof(word));
	
	if(wlen <= 0) return 1;

	if(word[wlen-1] == '\n')
		word[wlen-1] = '\0';
	else
		word[wlen] = '\0';
	
	int fd = open(argv[1], O_RDONLY);
	if(fd == -1){
		write(2, "Error opening file\n", 19);
		return 1;
	}

	char buf[4096];
	int n = read(fd, buf, sizeof(buf));

	int start = 0;
	for(int i = 0; i <= n; i++){
		if(i == n || buf[i] == '\n'){
			buf[i] = '\0';

			if(strstr(&buf[start], word)){
				write(1, &buf[start], strlen(&buf[start]));
				write(1, "\n", 1); //newline after printing
			}

			start = i + 1;
		}
	}

	close(fd);
	return 0;
}

gcc mygrep.c -o mygrep
./mygrep sample.txt

sample.txt
hello world
this is test
grep program
hello again
 ------------------------------------------------------------------------------------------
 ************************** Assignment no 5  **************************
Q.Write an application in xv6 Operating System (not kernel). 

It can be either of the following: cp, head, tail, (or any other that you discuss with the faculty) 
Submit: cp.c,  head.c, tail.c, etc. .Also submit Modified Makefile 

cp.c=>
#include "types.h"
#include "stat.h"
#include "user.h"
#include "fcntl.h"

char buf[512];
int main(int argc, char *argv[]){
	int f1, f2, n;
	if(argc != 3){
		printf(2, "usage: cp file1 file2\n");
		exit();
	}
	f1 = open(argv[1], O_RDONLY);
	if(f1 < 0){
		printf(2, "cp: cannot open %s\n", argv[1]);
		exit();
	}
	f2 = open(argv[2], O_CREATE|O_WRONLY);
	if(f2 < 0){
		printf(2, "cp: cannot create %s\n", argv[2]);
		close(f1);
		exit();
	}
	while((n = read(f1, buf, sizeof(buf))) > 0){
		write(f2, buf, n);
	}
	close(f1);
	close(f2);
	exit();
}

head.c=>
#include "types.h"
#include "stat.h"
#include "user.h"
#include "fcntl.h"

int main(int argc, char* argv[]){
	int fd, n, lines = 10, count = 0;
	char buf[512];
	if(argc < 2){
		printf(2, "Usage: head file [n]\n");
		exit();
	}
	if(argc == 3){
		lines = atoi(argv[2]);
	}
	fd = open(argv[1], O_RDONLY);
	if(fd < 0){
		printf(2, "head: cannot open %s\n", argv[1]);
		exit();
	}
	while((n = read(fd, buf, sizeof(buf))) > 0 && count < lines){
		for(int i = 0; i<n; i++){
			printf(1, "%c", buf[i]);
			if(buf[i] == '\n'){
				count++;
				if(count >= lines){
					close(fd);
					exit();
				}
			}
		}
	}
	close(fd);
	exit();
}

tail.c =>
#include "types.h"
#include "stat.h"
#include "user.h"
#include "fcntl.h"

int main(int argc, char *argv[]){
	int fd, lines = 10, count = 0, total = 0;
	char buf[512];
	if(argc < 2){
		printf(2, "Usage: tail file [n]\n");
		exit();
	}
	if(argc == 3){
		lines = atoi(argv[2]);
	}
	fd = open(argv[1], O_RDONLY);
	if(fd  < 0){
		printf(2, "tail: cannot open %s\n", argv[1]);
		exit();
	}
	//reading entire file
	total = read(fd, buf, sizeof(buf));
	close(fd);
	if(total <= 0){
		exit();
	}
	for(int i = 0; i<total; i++){
		if(buf[i] == '\n'){
			count++;
		}
	}
	int target = count - lines;
	if(target < 0) target = 0;
	count = 0;
	for(int i = 0; i < total; i++){
		if(buf[i] == '\n'){
			if(count >= target){
				printf(1, "\n");
			}
			count++;
		}else{
			if(count >= target){
				printf(1, "%c", buf[i]);
			}
		}
	}
	exit();
}

cp file1 file2
head filename
tail filename
and for makefile
vim Makefile
Find the line: UPROGS=\Add your user programs here:
        _cp\
        _head\
        _tail\
make clean
make
make qemu
 ------------------------------------------------------------------------------------------
 ************************** Assignment no 6  **************************
 lseek system call in xv6 
 
  
1) Add syscall number → syscall.h
#define SYS_lseek 22

2)Register syscall  → syscall.c
Also add declaration: extern int sys_lseek(void);
Add in syscalls[] array: [SYS_lseek] = sys_lseek,

3)sysfile.c — Core Logic of lseek()
int
sys_lseek(void)
{
  int fd, offset, whence;
  struct file *f;
  if(argfd(0, &fd, &f) < 0 || argint(1, &offset) < 0 || argint(2, &whence) < 0)
    return -1;
  if(f->type != FD_INODE && f->type != FD_PIPE)
    return -1;

  int newoff;
  switch(whence){
  case 0:    newoff = offset;    break;
  case 1:    newoff = f->off + offset;    break;
  case 2:    newoff = f->ip->size + offset;    break;
  default:    return -1;
  }
  if(newoff < 0)
    return -1;

  f->off = newoff;
  return newoff;
}

4) Expose syscall to user programs → user.h
int lseek(int fd, int offset, int whence);

5) Add syscall entry stub → usys.S
Add: SYSCALL(lseek)

//optional is told then go fo it, for testing
6) Create user program → nano lseektst.c
#include "types.h"
#include "stat.h"
#include "user.h"
#include "fcntl.h"

int main() {
  int fd = open("README", O_RDONLY);
  if(fd < 0){
    printf(1, "error opening file\n");
    exit();
  }
  // Move 5 bytes from beginning
  int pos = lseek(fd, 5, 0);
  printf(1, "New position = %d\n", pos);

  char buf[20];
  int n = read(fd, buf, 10);
  buf[n] = '\0';
  printf(1, "Data read = %s\n", buf);

  exit();
}


7) Add program to xv6 Makefile 
nano Makefile
Find:
UPROGS=\
        _cat\
        _echo\
        ...
Add:   _lseektst\
then 
make clean
make
make qemu
$ lseektst

create patch for this => git diff eeb7b415dbcb12cc362d0783e41c3d1f44066b17 > MIS.lseek.patch

 ------------------------------------------------------------------------------------------
 ************************** Assignment no 7  **************************
 Change free list management in xv6

All changes are done in: kalloc.c  (direct paste this code just safe about header files)

kalloc.c =>
#include "types.h"
#include "defs.h"
#include "param.h"
#include "memlayout.h"
#include "spinlock.h"

/*
 * Stack-based physical page allocator for xv6.
 * Replaces the original linked-list freelist.
 * All free pages are stored in kmem.stack[] with kmem.top as stack pointer.
 */

#define MAXPAGES (PHYSTOP / PGSIZE)

struct {
  struct spinlock lock;
  int use_lock;
  void *stack[MAXPAGES];  // array to hold free pages
  int top;                // stack pointer
} kmem;

extern char end[]; // first address after kernel loaded from ELF file

void freerange(void *vstart, void *vend);

void
kinit1(void *vstart, void *vend)
{
  initlock(&kmem.lock, "kmem");
  kmem.use_lock = 0;
  kmem.top = 0;          // initialize empty stack
  freerange(vstart, vend);
}

void
kinit2(void *vstart, void *vend)
{
  freerange(vstart, vend);
  kmem.use_lock = 1;
}

void
freerange(void *vstart, void *vend)
{
  char *p;
  for(p = (char*)PGROUNDUP((uint)vstart); p + PGSIZE <= (char*)vend; p += PGSIZE)
    kfree(p);
}

void
kfree(char *v)
{
  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
    panic("kfree");

  // Fill with junk to catch dangling refs
  memset(v, 1, PGSIZE);

  if(kmem.use_lock)
    acquire(&kmem.lock);

  // push this physical page onto the stack
  if(kmem.top < MAXPAGES)
    kmem.stack[kmem.top++] = v;
  else
    panic("kfree: stack full");

  if(kmem.use_lock)
    release(&kmem.lock);
}

char*
kalloc(void)
{
  void *r = 0;

  if(kmem.use_lock)
    acquire(&kmem.lock);

  // pop a free page from the stack
  if(kmem.top > 0)
    r = kmem.stack[--kmem.top];
  else
    r = 0;

  if(kmem.use_lock)
    release(&kmem.lock);

  if(r)
    memset(r, 5, PGSIZE); // fill allocated page with junk for debugging

  return (char*)r;
}

patch file generation:
git branch
# Create new branch
git checkout -b xv6-free-list
# Edit kalloc.c (replace linked list with stack)
vim kalloc.c
# Verify changes
git status
# Build xv6
make clean
make
make qemu
# Generate patch
git diff master > /tmp/MIS.patch
 ------------------------------------------------------------------------------------------
 ************************** Assignment no 9  **************************
 Print an inode, given Inode number
 
 inodenumber.c  =>
#define _LARGEFILE64_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <sys/stat.h>
#include <ext2fs/ext2_fs.h>

#define SUPERBLOCK_OFFSET 1024

// Read superblock from device
int read_superblock(int fd, struct ext2_super_block *sb)
{
    lseek64(fd, SUPERBLOCK_OFFSET, SEEK_SET);
    read(fd, sb, sizeof(struct ext2_super_block));

    if (sb->s_magic != EXT2_SUPER_MAGIC)
    {
        printf("Error: Not an ext2 filesystem\n");
        return -1;
    }
    return 0;
}

// Read a specific inode from disk
int read_inode(int fd, struct ext2_super_block *sb, int inode_num, struct ext2_inode *inode)
{
    struct ext2_group_desc gd;
    int inodes_per_group = sb->s_inodes_per_group;
    int block_size = 1024 << sb->s_log_block_size;

    // Determine which block group the inode belongs to
    int group_num = (inode_num - 1) / inodes_per_group;
    int index = (inode_num - 1) % inodes_per_group;

    // Read that group descriptor
    if (read_group_desc(fd, sb, group_num, &gd) < 0)
    {
        printf("Error reading group descriptor\n");
        return -1;
    }

    // Calculate inode table offset#define _LARGEFILE64_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <sys/stat.h>
#include <ext2fs/ext2_fs.h>

#define SUPERBLOCK_OFFSET 1024

// Read superblock from device
int read_superblock(int fd, struct ext2_super_block *sb)
{
    lseek64(fd, SUPERBLOCK_OFFSET, SEEK_SET);
    read(fd, sb, sizeof(struct ext2_super_block));

    if (sb->s_magic != EXT2_SUPER_MAGIC)
    {
        printf("Error: Not an ext2 filesystem\n");
        return -1;
    }
    return 0;
}

// Read a specific inode from disk
int read_inode(int fd, struct ext2_super_block *sb, int inode_num, struct ext2_inode *inode)
{
    struct ext2_group_desc gd;
    int inodes_per_group = sb->s_inodes_per_group;
    int block_size = 1024 << sb->s_log_block_size;

    // Determine which block group the inode belongs to
    int group_num = (inode_num - 1) / inodes_per_group;
    int index = (inode_num - 1) % inodes_per_group;

    // Read that group descriptor
    if (read_group_desc(fd, sb, group_num, &gd) < 0)
    {
        printf("Error reading group descriptor\n");
        return -1;
    }

    // Calculate inode table offset
    long inode_table_block = gd.bg_inode_table;
    long offset = inode_table_block * block_size + index * sb->s_inode_size;

    // Seek and read inode
    lseek64(fd, offset, SEEK_SET);
    read(fd, inode, sizeof(struct ext2_inode));

    return 0;
}

// Read group descriptor for a block group
int read_group_desc(int fd, struct ext2_super_block *sb, int group_num, struct ext2_group_desc *gd)
{
    int block_size = 1024 << sb->s_log_block_size;

    // Group descriptor table location
    int gdt_block = (block_size == 1024) ? 2 : 1;
    long offset = gdt_block * block_size + group_num * sizeof(struct ext2_group_desc);

    lseek64(fd, offset, SEEK_SET);
    read(fd, gd, sizeof(struct ext2_group_desc));

    return 0;
}

// Print inode details
void print_inode_info(int inode_num, struct ext2_inode *inode)
{
    printf("\n=== Inode %d ===\n\n", inode_num);

    printf("Permissions: %o\n", inode->i_mode & 0777);
    printf("Owner: UID=%d, GID=%d\n", inode->i_uid, inode->i_gid);
    printf("Size: %u bytes\n", inode->i_size);
    printf("Links: %d\n", inode->i_links_count);
    printf("Blocks: %u\n", inode->i_blocks);

    // Print block pointers
    printf("Direct blocks:\n");
    for (int i = 0; i < EXT2_NDIR_BLOCKS; i++)
    {
        if (inode->i_block[i] != 0)
        {
            printf("  [%d] %u\n", i, inode->i_block[i]);
        }
    }

    if (inode->i_block[EXT2_IND_BLOCK] != 0)
    {
        printf("Indirect block: %u\n", inode->i_block[EXT2_IND_BLOCK]);
    }
    if (inode->i_block[EXT2_DIND_BLOCK] != 0)
    {
        printf("Double indirect: %u\n", inode->i_block[EXT2_DIND_BLOCK]);
    }
    if (inode->i_block[EXT2_TIND_BLOCK] != 0)
    {
        printf("Triple indirect: %u\n", inode->i_block[EXT2_TIND_BLOCK]);
    }
}

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        printf("Usage: %s <device> <inode_number>\n", argv[0]);
        return 1;
    }

    char *device = argv[1];
    int inode_num = atoi(argv[2][0] == '/' ? argv[2] + 1 : argv[2]);

    if (inode_num == 0)
    {
        printf("Invalid inode number\n");
        return 1;
    }

    // Open device
    int fd = open(device, O_RDONLY);
    if (fd < 0)
    {
        printf("Error opening device (run with sudo)\n");
        return 1;
    }

    // Read superblock
    struct ext2_super_block sb;
    if (read_superblock(fd, &sb) < 0)
    {
        close(fd);
        return 1;
    }

    // Read and print inode
    struct ext2_inode inode;
    read_inode(fd, &sb, inode_num, &inode);
    print_inode_info(inode_num, &inode);

    close(fd);
    return 0;
}

    long inode_table_block = gd.bg_inode_table;
    long offset = inode_table_block * block_size + index * sb->s_inode_size;

    // Seek and read inode
    lseek64(fd, offset, SEEK_SET);
    read(fd, inode, sizeof(struct ext2_inode));

    return 0;
}

// Read group descriptor for a block group
int read_group_desc(int fd, struct ext2_super_block *sb, int group_num, struct ext2_group_desc *gd)
{
    int block_size = 1024 << sb->s_log_block_size;

    // Group descriptor table location
    int gdt_block = (block_size == 1024) ? 2 : 1;
    long offset = gdt_block * block_size + group_num * sizeof(struct ext2_group_desc);

    lseek64(fd, offset, SEEK_SET);
    read(fd, gd, sizeof(struct ext2_group_desc));

    return 0;
}

// Print inode details
void print_inode_info(int inode_num, struct ext2_inode *inode)
{
    printf("\n=== Inode %d ===\n\n", inode_num);

    printf("Permissions: %o\n", inode->i_mode & 0777);
    printf("Owner: UID=%d, GID=%d\n", inode->i_uid, inode->i_gid);
    printf("Size: %u bytes\n", inode->i_size);
    printf("Links: %d\n", inode->i_links_count);
    printf("Blocks: %u\n", inode->i_blocks);

    // Print block pointers
    printf("Direct blocks:\n");
    for (int i = 0; i < EXT2_NDIR_BLOCKS; i++)
    {
        if (inode->i_block[i] != 0)
        {
            printf("  [%d] %u\n", i, inode->i_block[i]);
        }
    }

    if (inode->i_block[EXT2_IND_BLOCK] != 0)
    {
        printf("Indirect block: %u\n", inode->i_block[EXT2_IND_BLOCK]);
    }
    if (inode->i_block[EXT2_DIND_BLOCK] != 0)
    {
        printf("Double indirect: %u\n", inode->i_block[EXT2_DIND_BLOCK]);
    }
    if (inode->i_block[EXT2_TIND_BLOCK] != 0)
    {
        printf("Triple indirect: %u\n", inode->i_block[EXT2_TIND_BLOCK]);
    }
}

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        printf("Usage: %s <device> <inode_number>\n", argv[0]);
        return 1;
    }

    char *device = argv[1];
    int inode_num = atoi(argv[2][0] == '/' ? argv[2] + 1 : argv[2]);

    if (inode_num == 0)
    {
        printf("Invalid inode number\n");
        return 1;
    }

    // Open device
    int fd = open(device, O_RDONLY);
    if (fd < 0)
    {
        printf("Error opening device (run with sudo)\n");
        return 1;
    }

    // Read superblock
    struct ext2_super_block sb;
    if (read_superblock(fd, &sb) < 0)
    {
        close(fd);
        return 1;
    }

    // Read and print inode
    struct ext2_inode inode;
    read_inode(fd, &sb, inode_num, &inode);
    print_inode_info(inode_num, &inode);

    close(fd);
    return 0;
}

comiplation and exceution =>>>

(optional)
sudo apt update
sudo apt install e2fsprogs e2fslibs-dev

gcc inodenumber.c -o inodenumber
sudo ./inodenumber /dev/sdb1 10

if above fails then =>
dd if=/dev/zero of=ext2.img bs=1M count=10
mkfs.ext2 ext2.img
sudo losetup -fP ext2.img
losetup -a       # find /dev/loopX

sudo ./inodenumber /dev/loop0 2 (here find your loop number and write it )
------------------------------------------------------------------------------------------
 ************************** Assignment no 10  **************************
 Slab allocator in xv6 
 
 In slab.c =>
#include "types.h"
#include "defs.h"
#include "memlayout.h"
#include "mmu.h"
#include "spinlock.h"
#include "slab.h"


struct slab {
  struct slab *next;
  void *free;
  int refcount;
  char data[0];
};

void slab_init(struct slab_cache *cache, uint size) {
  initlock(&cache->lock, "slab");
  cache->size = size;
  cache->slabs = 0;
}

void* slab_alloc(struct slab_cache *cache) {
  acquire(&cache->lock);
  struct slab *s = cache->slabs;

  if(!s || !s->free) {
    s = (struct slab*)kalloc();
    if(!s){
      release(&cache->lock);
      return 0;
    }
    s->next = cache->slabs;
    s->free = s->data;
    s->refcount = PGSIZE / cache->size;
    cache->slabs = s;

    // initialize free list
    char *p = s->data;
    for(int i = 0; i < s->refcount - 1; i++) {
      *(void **)p = p + cache->size;
      p += cache->size;
    }
    *(void **)p = 0;
  }

  void *obj = s->free;
  s->free = *(void **)s->free;
  release(&cache->lock);
  return obj;
}

void slab_free(struct slab_cache *cache, void *obj) {
  acquire(&cache->lock);
  struct slab *s = cache->slabs;
  *(void **)obj = s->free;
  s->free = obj;
  release(&cache->lock);
}

In slab.h =>
#ifndef SLAB_H
#define SLAB_H

#include "types.h"

struct slab_cache {
  uint size;
  struct spinlock lock;
  struct slab *slabs;
};

void* slab_alloc(struct slab_cache *cache);
void slab_free(struct slab_cache *cache, void *obj);
void slab_init(struct slab_cache *cache, uint size);

#endif
----------------------------------------------------------
commands for execution 

Step 1: Modify file.c
FIND this block (near top of file.c):
struct {
  struct spinlock lock;
  struct file file[NFILE];
} ftable;

❌ DELETE ONLY THE ARRAY:

Replace it with:
struct {
  struct spinlock lock;
} ftable;

Do NOT delete the lock.
Do NOT delete the struct wrapper.
-------------
Step 2 Add slab allocator usage

Right below includes:  #include "slab.h"
Add global cache: struct slab_cache file_cache;
------------
Step 3 Modify fileinit()
FIND original:  void fileinit(void) REPLACE with:
void
fileinit(void)
{
  initlock(&ftable.lock, "ftable");
  slab_init(&file_cache, sizeof(struct file));
}
---------------
Step 4: Modify filealloc()
REPLACE with:
f = slab_alloc(&file_cache);
if(f){
    f->ref = 1;
    f->type = FD_NONE;
    f->readable = 0;
    f->writable = 0;
    f->pipe = 0;
    f->ip = 0;
    f->off = 0;
}
release(&ftable.lock);
return f;
------------------
Step 5: Modify fileclose()
FIND this existing block inside fileclose():
if(--ff.ref > 0){
  release(&ftable.lock);
  return;
}
Below that, at end of fileclose, you will see:
f->ref = 0;
release(&ftable.lock);

Replace that last part with:
// return to slab allocator
slab_free(&file_cache, f);
release(&ftable.lock);
--------------------
Modify Makefile
FIND:
OBJS = \
  bio.o\
  console.o\
  ...
  kalloc.o

Add:
  slab.o\
-------------------
Step-by-step: Create patch file 

cd xv6-public
git init
git add .
git commit -m "Base xv6"
git checkout -b slab-allocator
Make all modifications, then:

git add slab.c slab.h file.c Makefile
git commit -m "Added slab allocator for struct file"
git checkout master
git diff master..slab-allocator > MIS.slab.patch

------------------------------------------------------------------------------------------
 ************************** Assignment no 11  **************************
  Implement 1-1 threading library
  You need to implement userland threads on Linux systems, using 1-1 thread mapping.

The following functions should be implemented:
thread_create(); // create a thread
thread_join() ; // parent waits for thread
thread_exit(); // thread exit, thread exits

The parameters for the three functions above should be defined by you. Essentially the call to thread_create() involves a call to clone() with proper parameters, the call to thread_join() involves a call to some variant of wait() with proper parameters. Think about thread_exit(). Of course, you need to take care of the list of processes also. You will also need to write a testing code, considering all possibilities

You need to provide these files: thread.h (with all declarations), and thread.c (code of functions), and a testing code test.c

#thread.c =>
#define _GNU_SOURCE
#include <sched.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include "thread.h"

#define STACK_SIZE 65536 // 64kb stack for each thread

struct mythread{
	pid_t tid;
	void *stack;
	void *retval;
	void *(*fn)(void *);
	void *arg;
};

static struct mythread threads[10];
static int tcount = 0;

//get tid for current thread
static pid_t get_tid(){
	return syscall(SYS_gettid);
}

static int start_func(void *ptr){
	struct mythread *t = (struct mythread *)ptr;
	void *res = t->fn(t->arg);
	t->retval = res;
	_exit(0);
	return 0;
}

int thread_create(thread_t *tid, void *(*fn)(void *), void *arg){
	if(tcount >= 10){
		printf("Too many threads !\n");
		return -1;
	}

	struct mythread *t = &threads[tcount];
	t->stack = malloc(STACK_SIZE);
	if(!t->stack) return -1;
	
	t->fn = fn;
	t->arg = arg;

	// clong flags: share memory (CLONE_VM) and send SIGCHLD to parent
	int flags = CLONE_VM | SIGCHLD;
	void *stack_top = (char *) t->stack + STACK_SIZE;

	pid_t child = clone(start_func, stack_top, flags, t);
	if(child == -1){
		perror("clone");
		free(t->stack);
		return -1;
	}

	t->tid = child;
	t->retval = NULL;

	*tid = child;
	tcount++;

	return 0;
}

int thread_join(thread_t tid, void **retval){
	int status;
	pid_t w = waitpid(tid, &status, 0);
	if(w == -1){
		perror("waitpid");
		return -1;
	}

	for(int i = 0; i<tcount; i++){
		if(threads[i].tid == tid){
			if(retval){
				*retval = threads[i].retval;
			}
			free(threads[i].stack);
			return 0;
		}	
	}

	return 0;
}

void thread_exit(void *retval){
	pid_t id = get_tid();
	for(int i = 0; i < tcount; i++){
		if(threads[i].tid == id){
			threads[i].retval = retval;
			break;
		}
	}
	_exit(0);
}
------------------------------------------------------------------------------------------
#thread.h  =>
#ifndef SIMPLE_THREAD_H
#define SIMPLE_THREAD_H

#include <sys/types.h>

typedef pid_t thread_t; //thread id

int thread_create(thread_t *tid, void *(*start_routine)(void *), void *arg);
int thread_join(thread_t tid, void **retval);
void thread_exit(void *retval);

#endif
------------------------------------------------------------------------------------------
**test.c=>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "thread.h"

void *work(void *arg){
	int num = *(int *)arg;
	for(int i = 0; i < 3; i++){
		printf("Thread %d -> running iteration %d\n", num, i);
		usleep(100000); //just slow down
	}

	int *ans = malloc(sizeof(int));
	*ans = num * 10; //return something
	return ans;
}

//thread that exits early
void *early(void *arg){
	printf("This thread will call thread_exit()\n");
	int *x = malloc(sizeof(int));
	*x = 999;
	thread_exit(x);
	return NULL;
}

int main(){
	thread_t t1, t2, t3;
	int a1 = 1;
	int a2 = 2;
	void *res1, *res2, *res3;

	printf("main: creating 2 normal threads and 1 that exits early !\n");

	if(thread_create(&t1, work, &a1) != 0){
		printf("Error creating t1\n");
		return 1;
	}

	if(thread_create(&t2, work, &a2) != 0){
		printf("Error creating t2\n");
		return 1;
	}
	if(thread_create(&t3, early, NULL) != 0){
		printf("Error creating t3\n");
		return 1;
	}

	printf("main: waiting for t1 ...\n");
	thread_join(t1, &res1);
	printf("main: t1 returned %d\n", *(int *)res1);
	free(res1);
	
	printf("main: waiting for t2 ...\n");
	thread_join(t2, &res2);
	printf("main: t2 returned %d\n", *(int *)res2);
	free(res2);

	printf("main: waiting for t3 ...\n");
	thread_join(t3, &res3);
	printf("main: t3 returned %d\n", *(int *)res3);
	free(res3);

	printf("main: done, all threads joined !\n");
	return 0;
}

command for execution=>
gcc -Wall -Wextra -g test.c thread.c -o test -pthread
./test
------------------------------------------------------------------------------------------
 ************************** Assignment no 3  **************************
 Write shell (Hard IMP )
 Read commands in loop, parse arguments/options, execute using your own execvp using PATH.
Show prompt with CWD; allow PS1="text" and PS1="\w$"; implement internal cd.
Handle all input/user errors cleanly.
Exit gracefully on exit or Ctrl-D.
Implement PATH=... and redirection <, > and >>.

 #include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <limits.h>   
#include <fcntl.h>    
#include <sys/stat.h> 

// #define MAX_INPUT 1024
#define MAX_ARGS 64

// prompt handling

char prompt[256] = "\\w$";
char PATH_var[1024] = "/bin:/usr/bin"; // default PATH for our custom exec search

void print_prompt()
{
    if (strcmp(prompt, "\\w$") == 0)
    {
        char cwd[PATH_MAX];
        if (getcwd(cwd, sizeof(cwd)) != NULL)
        {
            printf("%s $ ", cwd);
        }
        else
        {
            perror("getcwd");
            printf("$ ");
        }
    }
    else
    {
        printf("%s ", prompt);
    }
    fflush(stdout);
}

void change_directory(char *path)
{
    if (path == NULL)
    {
        // if no path is given, go to HOME directory
        char *home = getenv("HOME");
        if (home == NULL)
        {
            fprintf(stderr, "cd: HOME not set\n");
            return;
        }

        if (chdir(home) != 0)
        {
            perror("cd");
        }
    }
    else
    {
        if (chdir(path) != 0)
        {
            perror("cd");
        }
    }
}

// own execvp using PATH_var
int my_execvp(char *cmd, char *args[])
{
    struct stat st;

    // If command contains '/', treat it as a path and execute directly
    if (strchr(cmd, '/') != NULL)
    {
        execv(cmd, args);
        perror("execv");
        return -1;
    }

    if (PATH_var[0] == '\0')
    {
        fprintf(stderr, "%s: command not found\n", cmd);
        return -1;
    }

    char *path_copy = strdup(PATH_var);
    char *dir = strtok(path_copy, ":");

    while (dir != NULL)
    {
        char fullpath[PATH_MAX];
        snprintf(fullpath, sizeof(fullpath), "%s/%s", dir, cmd);

        if (stat(fullpath, &st) == 0 && (st.st_mode & S_IXUSR))
        {
            execv(fullpath, args);
            perror("execv failed!");
            free(path_copy);
            return -1;
        }
        dir = strtok(NULL, ":");
    }

    fprintf(stderr, "%s command not found\n", cmd);
    free(path_copy);
    return -1;
}

int main()
{
    char input[MAX_INPUT];
    char *args[MAX_ARGS];

    while (1)
    {
        print_prompt();

        if (fgets(input, MAX_INPUT, stdin) == NULL)
        {
            printf("\nHave a nice day!\n");
            break; // Ctrl+D exit
        }

        input[strcspn(input, "\n")] = '\0'; // remove newline

        if (strlen(input) == 0)
            continue; // empty input

        // exit
        if (strcmp(input, "exit") == 0)
        {
            printf("Have a nice day!\n");
            break;
        }

        // PS1 change
        if (strncmp(input, "PS1=", 4) == 0)
        {
            char *val = input + 4; // skip "PS1=" part
            size_t len = strlen(val);

            // If enclosed in quotes, strip them
            if (len >= 2 && val[0] == '"' && val[len - 1] == '"')
            {
                val[len - 1] = '\0'; // remove last quote
                val++;               // skip first quote
            }

            strcpy(prompt, val);
            continue;
        }

        // PATH change
        if (strncmp(input, "PATH=", 5) == 0)
        {
            strcpy(PATH_var, input + 5);
            continue;
        }

        // Tokenize
        char *token = strtok(input, " ");
        int i = 0;
        char *infile = NULL;
        char *outfile = NULL;
        int append_mode = 0;

        while (token != NULL && i < MAX_ARGS - 1)
        {
            if (strcmp(token, "<") == 0)
            {
                token = strtok(NULL, " ");
                infile = token;
            }
            else if (strcmp(token, ">") == 0)
            {
                token = strtok(NULL, " ");
                outfile = token;
                append_mode = 0;
            }
            else if (strcmp(token, ">>") == 0)
            {
                token = strtok(NULL, " ");
                outfile = token;
                append_mode = 1;
            }
            else
            {
                // remove quotes if present
                size_t tlen = strlen(token);
                if (tlen >= 2 && token[0] == '"' && token[tlen - 1] == '"')
                {
                    token[tlen - 1] = '\0';
                    token++;
                }
                args[i++] = token;
            }
            token = strtok(NULL, " ");
        }
        args[i] = NULL;

        if (args[0] == NULL)
            continue;

        // cd
        if (strcmp(args[0], "cd") == 0)
        {
            change_directory(args[1]);
            continue;
        }

        pid_t pid = fork();
        if (pid == 0)
        {
            // handle input redirection
            if (infile)
            {
                int fd = open(infile, O_RDONLY);
                if (fd < 0)
                {
                    perror("open input");
                    exit(EXIT_FAILURE);
                }
                dup2(fd, STDIN_FILENO);
                close(fd);
            }

            // handle output redirection
            if (outfile)
            {
                int fd;
                if (append_mode)
                {
                    fd = open(outfile, O_WRONLY | O_CREAT | O_APPEND, 0644);
                }
                else
                {
                    fd = open(outfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);
                }

                if (fd < 0)
                {
                    perror("open output");
                    exit(EXIT_FAILURE);
                }
                dup2(fd, STDOUT_FILENO);
                close(fd);
            }

            my_execvp(args[0], args);
            exit(EXIT_FAILURE);
        }
        else if (pid > 0)
        {
            int status;
            waitpid(pid, &status, 0);
        }
        else
        {
            perror("fork failed");
        }
    }
    return 0;
}

#comiplation
gcc -Wall -Wextra -g -o myshell myshell.c
./myshell
Test Example Commands Inside the Shell
ls
pwd
cd ..
ls > out.txt
echo "hello" >> file.txt
PATH=/usr/bin
PS1="mysh>"
exit
 ------------------------------------------------------------------------------------------
 ************************** Assignment no  8 **************************
 Assignment: Write a better shell
Improve your own shell code written in the Group-A assignment. The shell should support following features :
* Handle multiple pipes
* Handle Ctrl-C, Ctrl-z, Fg, Bg, jobs
* Handle "history" command

bettershell.c=>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <errno.h>

#define MAX_LINE 1024
#define MAX_ARGS 128
#define MAX_JOBS 50
#define MAX_HISTORY 50
#define MAX_PIPES 10

typedef struct {
    pid_t pgid;           // Process group ID
    char cmd[MAX_LINE];
    int running;          // 1=running, 0=stopped
    int background;       // 1=background, 0=foreground
} Job;

Job jobs[MAX_JOBS];
int job_count = 0;
char *history[MAX_HISTORY];
int history_count = 0;
pid_t shell_pgid;
int foreground_pgid = -1;

// Function declarations
void sigchld_handler(int sig);
void sigint_handler(int sig);
void sigtstp_handler(int sig);
void add_history(char *cmd);
void print_history();
void add_job(pid_t pgid, char *cmd, int running, int background);
void remove_job(int index);
void print_jobs();
int parse_line(char *line, char **args);
void execute_command(char **args, int background, char *full_cmd);
void execute_pipeline(char *line, int background);
void builtin_fg(int job_num);
void builtin_bg(int job_num);
void update_job_status();
int find_job_by_pgid(pid_t pgid);

// Signal handler for SIGCHLD
void sigchld_handler(int sig) {
    int status;
    pid_t pid;
    
    // Reap all terminated children
    while ((pid = waitpid(-1, &status, WNOHANG | WUNTRACED | WCONTINUED)) > 0) {
        int job_idx = find_job_by_pgid(pid);
        
        if (job_idx != -1) {
            if (WIFEXITED(status) || WIFSIGNALED(status)) {
                // Process terminated
                printf("\n[%d] Done\t%s\n", job_idx + 1, jobs[job_idx].cmd);
                remove_job(job_idx);
            } else if (WIFSTOPPED(status)) {
                // Process stopped
                jobs[job_idx].running = 0;
                printf("\n[%d] Stopped\t%s\n", job_idx + 1, jobs[job_idx].cmd);
            } else if (WIFCONTINUED(status)) {
                // Process continued
                jobs[job_idx].running = 1;
            }
        }
    }
}

// Signal handler for SIGINT (Ctrl-C)
void sigint_handler(int sig) {
    if (foreground_pgid > 0) {
        kill(-foreground_pgid, SIGINT);
    }
    printf("\n");
}

// Signal handler for SIGTSTP (Ctrl-Z)
void sigtstp_handler(int sig) {
    if (foreground_pgid > 0) {
        kill(-foreground_pgid, SIGTSTP);
        // Find and update job status
        int job_idx = find_job_by_pgid(foreground_pgid);
        if (job_idx != -1) {
            jobs[job_idx].running = 0;
            jobs[job_idx].background = 1;
            printf("\n[%d] Stopped\t%s\n", job_idx + 1, jobs[job_idx].cmd);
        }
        foreground_pgid = -1;
    }
    printf("\n");
}

// Add command to history
void add_history(char *cmd) {
    if (history_count < MAX_HISTORY) {
        history[history_count++] = strdup(cmd);
    }
}

// Print history
void print_history() {
    for (int i = 0; i < history_count; i++) {
        printf("%d %s\n", i + 1, history[i]);
    }
}

// Add job to job list
void add_job(pid_t pgid, char *cmd, int running, int background) {
    if (job_count < MAX_JOBS) {
        jobs[job_count].pgid = pgid;
        strncpy(jobs[job_count].cmd, cmd, MAX_LINE - 1);
        jobs[job_count].cmd[MAX_LINE - 1] = '\0';
        jobs[job_count].running = running;
        jobs[job_count].background = background;
        job_count++;
        if (background) {
            printf("[%d] %d\n", job_count, pgid);
        }
    }
}

// Remove job from job list
void remove_job(int index) {
    if (index >= 0 && index < job_count) {
        for (int i = index; i < job_count - 1; i++) {
            jobs[i] = jobs[i + 1];
        }
        job_count--;
    }
}

// Find job by process group ID
int find_job_by_pgid(pid_t pgid) {
    for (int i = 0; i < job_count; i++) {
        if (jobs[i].pgid == pgid) {
            return i;
        }
    }
    return -1;
}

// Print jobs
void print_jobs() {
    update_job_status();
    for (int i = 0; i < job_count; i++) {
        printf("[%d] %s\t%s\n", i + 1, 
               jobs[i].running ? "Running" : "Stopped", 
               jobs[i].cmd);
    }
}

// Update job status (check for terminated jobs)
void update_job_status() {
    int status;
    for (int i = 0; i < job_count; i++) {
        pid_t result = waitpid(-jobs[i].pgid, &status, WNOHANG | WUNTRACED);
        if (result > 0) {
            if (WIFEXITED(status) || WIFSIGNALED(status)) {
                remove_job(i);
                i--; // Adjust index after removal
            } else if (WIFSTOPPED(status)) {
                jobs[i].running = 0;
            }
        }
    }
}

// Parse command line into arguments
int parse_line(char *line, char **args) {
    int count = 0;
    char *token = strtok(line, " \t\n");
    while (token != NULL && count < MAX_ARGS - 1) {
        args[count++] = token;
        token = strtok(NULL, " \t\n");
    }
    args[count] = NULL;
    return count;
}

// Bring job to foreground
void builtin_fg(int job_num) {
    if (job_num < 1 || job_num > job_count) {
        printf("fg: no such job\n");
        return;
    }
    
    int job_idx = job_num - 1;
    pid_t pgid = jobs[job_idx].pgid;
    
    printf("%s\n", jobs[job_idx].cmd);
    
    // Give terminal control to the job
    tcsetpgrp(STDIN_FILENO, pgid);
    
    // Continue the job if it's stopped
    if (!jobs[job_idx].running) {
        kill(-pgid, SIGCONT);
        jobs[job_idx].running = 1;
    }
    
    jobs[job_idx].background = 0;
    foreground_pgid = pgid;
    
    // Wait for the job to complete or stop
    int status;
    waitpid(-pgid, &status, WUNTRACED);
    
    // Take back terminal control
    tcsetpgrp(STDIN_FILENO, shell_pgid);
    foreground_pgid = -1;
    
    if (WIFEXITED(status) || WIFSIGNALED(status)) {
        remove_job(job_idx);
    } else if (WIFSTOPPED(status)) {
        jobs[job_idx].running = 0;
        jobs[job_idx].background = 1;
        printf("\n[%d] Stopped\t%s\n", job_num, jobs[job_idx].cmd);
    }
}

// Continue job in background
void builtin_bg(int job_num) {
    if (job_num < 1 || job_num > job_count) {
        printf("bg: no such job\n");
        return;
    }
    
    int job_idx = job_num - 1;
    if (jobs[job_idx].running) {
        printf("bg: job already running\n");
        return;
    }
    
    jobs[job_idx].running = 1;
    jobs[job_idx].background = 1;
    kill(-jobs[job_idx].pgid, SIGCONT);
    printf("[%d] %s &\n", job_num, jobs[job_idx].cmd);
}

// Execute single command
void execute_command(char **args, int background, char *full_cmd) {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Child process
        pid = getpid();
        setpgid(pid, pid);  // Create new process group
        
        if (!background) {
            tcsetpgrp(STDIN_FILENO, pid);  // Give terminal to child
        }
        
        // Reset signal handlers to default
        signal(SIGINT, SIG_DFL);
        signal(SIGTSTP, SIG_DFL);
        signal(SIGCHLD, SIG_DFL);
        
        if (execvp(args[0], args) < 0) {
            perror("bettershell");
            exit(1);
        }
    } else if (pid > 0) {
        // Parent process
        setpgid(pid, pid);  // Ensure child is in its own group
        
        if (background) {
            add_job(pid, full_cmd, 1, 1);
        } else {
            foreground_pgid = pid;
            int status;
            waitpid(pid, &status, WUNTRACED);
            
            tcsetpgrp(STDIN_FILENO, shell_pgid);  // Take back terminal
            foreground_pgid = -1;
            
            if (WIFSTOPPED(status)) {
                add_job(pid, full_cmd, 0, 1);
                printf("\n[%d] Stopped\t%s\n", job_count, full_cmd);
            }
        }
    } else {
        perror("fork");
    }
}

// Execute pipeline with multiple pipes
void execute_pipeline(char *line, int background) {
    char *cmds[MAX_PIPES];
    int num_cmds = 0;
    
    // Split by pipe
    char *token = strtok(line, "|");
    while (token != NULL && num_cmds < MAX_PIPES) {
        cmds[num_cmds++] = token;
        token = strtok(NULL, "|");
    }
    
    int pipes[MAX_PIPES - 1][2];
    pid_t pids[MAX_PIPES];
    pid_t pgid = 0;
    
    // Create all pipes
    for (int i = 0; i < num_cmds - 1; i++) {
        if (pipe(pipes[i]) < 0) {
            perror("pipe");
            return;
        }
    }
    
    // Execute each command
    for (int i = 0; i < num_cmds; i++) {
        pids[i] = fork();
        
        if (pids[i] == 0) {
            // Child process
            if (pgid == 0) {
                pgid = getpid();
            }
            setpgid(getpid(), pgid);
            
            if (!background && i == 0) {
                tcsetpgrp(STDIN_FILENO, pgid);
            }
            
            // Reset signals
            signal(SIGINT, SIG_DFL);
            signal(SIGTSTP, SIG_DFL);
            signal(SIGCHLD, SIG_DFL);
            
            // Set up input
            if (i > 0) {
                dup2(pipes[i - 1][0], STDIN_FILENO);
            }
            
            // Set up output
            if (i < num_cmds - 1) {
                dup2(pipes[i][1], STDOUT_FILENO);
            }
            
            // Close all pipe fds
            for (int j = 0; j < num_cmds - 1; j++) {
                close(pipes[j][0]);
                close(pipes[j][1]);
            }
            
            // Parse and execute
            char *args[MAX_ARGS];
            parse_line(cmds[i], args);
            execvp(args[0], args);
            perror("bettershell");
            exit(1);
        } else if (pids[i] > 0) {
            // Parent process
            if (pgid == 0) {
                pgid = pids[i];
            }
            setpgid(pids[i], pgid);
        }
    }
    
    // Close all pipes in parent
    for (int i = 0; i < num_cmds - 1; i++) {
        close(pipes[i][0]);
        close(pipes[i][1]);
    }
    
    if (background) {
        add_job(pgid, line, 1, 1);
    } else {
        foreground_pgid = pgid;
        int status;
        
        // Wait for all processes in the pipeline
        for (int i = 0; i < num_cmds; i++) {
            waitpid(pids[i], &status, WUNTRACED);
            if (WIFSTOPPED(status) && i == num_cmds - 1) {
                add_job(pgid, line, 0, 1);
                printf("\n[%d] Stopped\t%s\n", job_count, line);
            }
        }
        
        tcsetpgrp(STDIN_FILENO, shell_pgid);
        foreground_pgid = -1;
    }
}

int main() {
    shell_pgid = getpid();
    setpgid(shell_pgid, shell_pgid);
    tcsetpgrp(STDIN_FILENO, shell_pgid);
    
    // Set up signal handlers
    signal(SIGINT, sigint_handler);
    signal(SIGTSTP, sigtstp_handler);
    signal(SIGCHLD, sigchld_handler);
    signal(SIGTTOU, SIG_IGN);
    signal(SIGTTIN, SIG_IGN);
    
    char line[MAX_LINE];
    char line_copy[MAX_LINE];
    
    while (1) {
        printf("bettershell> ");
        fflush(stdout);
        
        if (!fgets(line, MAX_LINE, stdin)) {
            printf("\n");
            break;
        }
        
        if (line[0] == '\n') continue;
        
        // Remove newline
        line[strcspn(line, "\n")] = '\0';
        
        // Skip empty lines
        if (strlen(line) == 0) continue;
        
        // Save to history
        add_history(line);
        
        // Check for background
        int background = 0;
        int len = strlen(line);
        if (len > 0 && line[len - 1] == '&') {
            background = 1;
            line[len - 1] = '\0';
            // Trim trailing spaces
            while (len > 0 && line[len - 1] == ' ') {
                line[--len] = '\0';
            }
        }
        
        strcpy(line_copy, line);
        
        // Built-in commands
        if (strcmp(line, "history") == 0) {
            print_history();
            continue;
        }
        
        if (strcmp(line, "jobs") == 0) {
            print_jobs();
            continue;
        }
        
        if (strncmp(line, "fg", 2) == 0) {
            int job_num = 1;  // Default to job 1
            if (strlen(line) > 3) {
                job_num = atoi(line + 3);
            } else if (job_count > 0) {
                job_num = job_count;  // Use most recent job
            }
            builtin_fg(job_num);
            continue;
        }
        
        if (strncmp(line, "bg", 2) == 0) {
            int job_num = 1;  // Default to job 1
            if (strlen(line) > 3) {
                job_num = atoi(line + 3);
            } else if (job_count > 0) {
                job_num = job_count;  // Use most recent job
            }
            builtin_bg(job_num);
            continue;
        }
        
        if (strcmp(line, "exit") == 0) {
            break;
        }
        
        // Check for pipeline
        if (strchr(line_copy, '|')) {
            execute_pipeline(line_copy, background);
        } else {
            char *args[MAX_ARGS];
            parse_line(line_copy, args);
            if (args[0] != NULL) {
                execute_command(args, background, line);
            }
        }
    }
    
    return 0;
}

#commands for compilation and execution
gcc bettershell.c -o bettershell
./bettershell
------------------------------
TEST COMMANDS FOR YOUR BETTER SHELL
1.basic commands
2. MULTIPLE PIPES (MANDATORY)
Test -pipe pipeline: ls -l | grep .c | wc -l
Test -pipe pipeline: cat /etc/passwd | grep root | cut -d: -f1
Test -pipe pipeline: ps aux | grep bash | awk '{print $2}' | wc -l
3. BACKGROUND & JOB CONTROL
Start a job in background
sleep 20 &
sleep 30 &
sleep 40 &
4. CHECK JOBS LIST
jobs
Expected:
[1] Running sleep 20
[2] Running sleep 30
[3] Running sleep 40
5.history
6.TEST CTRL-C (terminate foreground)
Run:sleep 50
Press:Ctrl + C
Expected:^C(kill foreground process)
7. TEST CTRL-Z (stop process)
Run this in foreground: sleep 100
Press: Ctrl + Z
Expected:[1] Stopped sleep 100
Check:jobs
 ------------------------------------------------------------------------------------------
 ************************** Assignment no  **************************
